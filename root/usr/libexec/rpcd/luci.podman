#!/bin/sh
# RPC backend for LuCI Podman app

. /usr/share/libubox/jshn.sh

# Read socket path from UCI config, fallback to default
SOCKET=$(uci -q get podman.globals.socket_path 2>/dev/null)
SOCKET="${SOCKET:-/run/podman/podman.sock}"
API_BASE="/v5.0.0/libpod"

json_error() {
	json_init
	json_add_string error "$1"
	[ -n "$2" ] && json_add_string details "$2"
	[ -n "$3" ] && json_add_string code "$2"
	json_dump
	exit 1
}

# Route validation failures through json_error for JSON output
fail_validation() { json_error "$1"; }

. /usr/share/podman/validation.sh

# Check boolean parameter (JSON booleans become 1/0 via ubus)
is_true() {
	[ "$1" = "true" ] || [ "$1" = "1" ]
}

get_json_params() {
	read -r input
	json_load "$input"
	for var in "$@"; do
		json_get_var "$var" "$var"
	done
}

curl_request() {
	local method="$1"
	local path="$2"
	local data="$3"
	local timeout="${4:-30}"
	local result exit_code

	if [ -n "$data" ]; then
		result=$(curl -s -m "$timeout" --unix-socket "$SOCKET" -X "$method" \
			-H "Content-Type: application/json" \
			-d "$data" \
			"http://localhost$path" 2>&1)
		exit_code=$?
	else
		result=$(curl -s -m "$timeout" --unix-socket "$SOCKET" -X "$method" \
			"http://localhost$path" 2>&1)
		exit_code=$?
	fi

	if [ $exit_code -ne 0 ]; then
		json_error "Request failed" "curl exit code $exit_code" "$exit_code"
		return $exit_code
	fi

	case "$result" in
		\[*)
			echo "{\"data\":$result}"
			;;
		*)
			echo "$result"
			;;
	esac
	return 0
}

add_force() {
	is_true "$2" && echo "${1}?force=true" || echo "$1"
}

case "$1" in
	list)
		cat <<EOF
{
	"containers_list": { "query": "" },
	"container_inspect": { "id": "" },
	"container_start": { "id": "" },
	"container_stop": { "id": "" },
	"container_restart": { "id": "" },
	"container_remove": { "id": "", "force": false, "depend": false },
	"container_stats": { "id": "" },
	"container_create": { "data": {} },
	"container_rename": { "id": "", "name": "" },
	"container_update": { "id": "", "data": {} },
	"container_healthcheck_run": { "id": "" },
	"container_top": { "id": "", "ps_args": "" },
	"images_list": {},
	"image_inspect": { "id": "" },
	"image_remove": { "id": "", "force": false },
	"image_manifest_inspect": { "image": "" },
	"networks_list": {},
	"network_inspect": { "name": "" },
	"network_remove": { "name": "", "force": false },
	"network_create": { "data": {} },
	"network_connect": { "name": "", "data": {} },
	"network_disconnect": { "name": "", "data": {} },
	"volumes_list": {},
	"volume_inspect": { "name": "" },
	"volume_remove": { "name": "", "force": false },
	"volume_create": { "data": {} },
	"pods_list": {},
	"pod_inspect": { "name": "" },
	"pod_start": { "name": "" },
	"pod_stop": { "name": "" },
	"pod_restart": { "name": "" },
	"pod_pause": { "name": "" },
	"pod_unpause": { "name": "" },
	"pod_remove": { "name": "", "force": false },
	"pod_create": { "data": {} },
	"pod_stats": { "name": "" },
	"secrets_list": {},
	"secret_inspect": { "name": "" },
	"secret_create": { "name": "", "data": "" },
	"secret_remove": { "name": "" },
	"system_df": {},
	"system_prune": { "all": false, "volumes": false },
	"version": {},
	"info": {},
	"init_script_generate": { "name": "" },
	"init_script_show": { "name": "" },
	"init_script_status": { "name": "" },
	"init_script_set_enabled": { "name": "", "enabled": false },
	"init_script_remove": { "name": "" },
	"container_recreate": { "command": [] },
	"system_debug": {}
}
EOF
		;;
	call)
		json_init

		# system_debug runs before socket check (it diagnoses socket issues)
		if [ "$2" = "system_debug" ]; then
			read -r input

			json_add_array checks

			# 1. Podman binary
			if [ -x /usr/bin/podman ]; then
				podman_ver=$(/usr/bin/podman --version 2>/dev/null | head -1)
				json_add_object; json_add_string name "podman_binary"; json_add_string label "Podman Binary"; json_add_string status "ok"; json_add_string detail "/usr/bin/podman"; json_add_string message "$podman_ver"; json_close_object
			else
				json_add_object; json_add_string name "podman_binary"; json_add_string label "Podman Binary"; json_add_string status "error"; json_add_string detail "/usr/bin/podman"; json_add_string message "Not found or not executable"; json_close_object
			fi

			# 2. Podman socket exists
			if [ -S "$SOCKET" ]; then
				json_add_object; json_add_string name "podman_socket"; json_add_string label "Podman Socket"; json_add_string status "ok"; json_add_string detail "$SOCKET"; json_add_string message "Socket file exists"; json_close_object
			else
				json_add_object; json_add_string name "podman_socket"; json_add_string label "Podman Socket"; json_add_string status "error"; json_add_string detail "$SOCKET"; json_add_string message "Socket not found"; json_close_object
			fi

			# 3. Socket responsive (only if socket exists)
			if [ -S "$SOCKET" ]; then
				ping_result=$(curl -s -m 5 --unix-socket "$SOCKET" "http://localhost${API_BASE}/_ping" 2>&1)
				if [ "$ping_result" = "OK" ]; then
					json_add_object; json_add_string name "socket_responsive"; json_add_string label "Socket Responsive"; json_add_string status "ok"; json_add_string detail "API responding"; json_add_string message ""; json_close_object
				else
					json_add_object; json_add_string name "socket_responsive"; json_add_string label "Socket Responsive"; json_add_string status "warn"; json_add_string detail "API not responding"; json_add_string message "$ping_result"; json_close_object
				fi
			else
				json_add_object; json_add_string name "socket_responsive"; json_add_string label "Socket Responsive"; json_add_string status "error"; json_add_string detail "Skipped"; json_add_string message "Socket not available"; json_close_object
			fi

			# 4. curl binary
			if command -v curl >/dev/null 2>&1; then
				json_add_object; json_add_string name "curl_binary"; json_add_string label "curl"; json_add_string status "ok"; json_add_string detail "$(command -v curl)"; json_add_string message "Available"; json_close_object
			else
				json_add_object; json_add_string name "curl_binary"; json_add_string label "curl"; json_add_string status "error"; json_add_string detail ""; json_add_string message "Not found - required for API calls"; json_close_object
			fi

			# 5. Init directory writable
			if [ -d /etc/init.d ] && [ -w /etc/init.d ]; then
				json_add_object; json_add_string name "init_dir_writable"; json_add_string label "Init Directory"; json_add_string status "ok"; json_add_string detail "/etc/init.d/"; json_add_string message "Writable"; json_close_object
			elif [ -d /etc/init.d ]; then
				json_add_object; json_add_string name "init_dir_writable"; json_add_string label "Init Directory"; json_add_string status "warn"; json_add_string detail "/etc/init.d/"; json_add_string message "Not writable - init scripts cannot be created"; json_close_object
			else
				json_add_object; json_add_string name "init_dir_writable"; json_add_string label "Init Directory"; json_add_string status "error"; json_add_string detail "/etc/init.d/"; json_add_string message "Directory not found"; json_close_object
			fi

			# 6. Startup template
			template="/usr/share/podman/procd-startup-template.sh"
			if [ -r "$template" ]; then
				json_add_object; json_add_string name "startup_template"; json_add_string label "Startup Template"; json_add_string status "ok"; json_add_string detail "$template"; json_add_string message "Readable"; json_close_object
			elif [ -f "$template" ]; then
				json_add_object; json_add_string name "startup_template"; json_add_string label "Startup Template"; json_add_string status "warn"; json_add_string detail "$template"; json_add_string message "Exists but not readable"; json_close_object
			else
				json_add_object; json_add_string name "startup_template"; json_add_string label "Startup Template"; json_add_string status "warn"; json_add_string detail "$template"; json_add_string message "Not found - init script generation will fail"; json_close_object
			fi

			# 7. Validation script
			validation="/usr/share/podman/validation.sh"
			if [ -r "$validation" ]; then
				json_add_object; json_add_string name "validation_script"; json_add_string label "Validation Script"; json_add_string status "ok"; json_add_string detail "$validation"; json_add_string message "Readable"; json_close_object
			else
				json_add_object; json_add_string name "validation_script"; json_add_string label "Validation Script"; json_add_string status "error"; json_add_string detail "$validation"; json_add_string message "Not found - RPC input validation unavailable"; json_close_object
			fi

			# 8. Podman API helper
			api_helper="/usr/libexec/podman-api"
			if [ -x "$api_helper" ]; then
				json_add_object; json_add_string name "podman_api_helper"; json_add_string label "Podman API Helper"; json_add_string status "ok"; json_add_string detail "$api_helper"; json_add_string message "Executable"; json_close_object
			elif [ -f "$api_helper" ]; then
				json_add_object; json_add_string name "podman_api_helper"; json_add_string label "Podman API Helper"; json_add_string status "warn"; json_add_string detail "$api_helper"; json_add_string message "Exists but not executable"; json_close_object
			else
				json_add_object; json_add_string name "podman_api_helper"; json_add_string label "Podman API Helper"; json_add_string status "warn"; json_add_string detail "$api_helper"; json_add_string message "Not found - logs/pull/volume operations will fail"; json_close_object
			fi

			# 9. RPC script
			rpc_script="/usr/libexec/rpcd/luci.podman"
			if [ -x "$rpc_script" ]; then
				json_add_object; json_add_string name "rpc_script"; json_add_string label "RPC Script"; json_add_string status "ok"; json_add_string detail "$rpc_script"; json_add_string message "Executable"; json_close_object
			else
				json_add_object; json_add_string name "rpc_script"; json_add_string label "RPC Script"; json_add_string status "error"; json_add_string detail "$rpc_script"; json_add_string message "Not executable"; json_close_object
			fi

			# 10. UCI config
			if uci -q get podman.globals >/dev/null 2>&1; then
				socket_cfg=$(uci -q get podman.globals.socket_path 2>/dev/null)
				json_add_object; json_add_string name "uci_config"; json_add_string label "UCI Config"; json_add_string status "ok"; json_add_string detail "podman.globals"; json_add_string message "socket_path=${socket_cfg:-default}"; json_close_object
			else
				json_add_object; json_add_string name "uci_config"; json_add_string label "UCI Config"; json_add_string status "warn"; json_add_string detail "/etc/config/podman"; json_add_string message "Config not found or not loadable"; json_close_object
			fi

			# 11. Containers config
			containers_conf="/etc/containers/containers.conf"
			if [ -r "$containers_conf" ]; then
				json_add_object; json_add_string name "containers_conf"; json_add_string label "Containers Config"; json_add_string status "ok"; json_add_string detail "$containers_conf"; json_add_string message "Readable"; json_close_object
			else
				json_add_object; json_add_string name "containers_conf"; json_add_string label "Containers Config"; json_add_string status "warn"; json_add_string detail "$containers_conf"; json_add_string message "Not found - using Podman defaults"; json_close_object
			fi

			# 12. Network config directory
			net_dir="/etc/containers/networks"
			if [ -d "$net_dir" ]; then
				net_count=$(ls -1 "$net_dir"/*.json 2>/dev/null | wc -l)
				json_add_object; json_add_string name "network_config_dir"; json_add_string label "Network Config Dir"; json_add_string status "ok"; json_add_string detail "$net_dir"; json_add_string message "${net_count} network(s)"; json_close_object
			else
				json_add_object; json_add_string name "network_config_dir"; json_add_string label "Network Config Dir"; json_add_string status "warn"; json_add_string detail "$net_dir"; json_add_string message "Not found"; json_close_object
			fi

			json_close_array
			json_dump
			exit 0
		fi

		# Check socket availability
		if [ ! -S "$SOCKET" ]; then
			json_error "Podman socket not found or not accessible"
			exit 1
		fi

		case "$2" in
			containers_list)
				get_json_params query
				path="${API_BASE}/containers/json"
				if [ -n "$query" ]; then
					validate_query_params "$query"
					path="${path}?${query}"
				fi
				curl_request "GET" "$path"
				;;
			container_inspect)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/json"
				;;
			container_start)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/start"
				;;
			container_stop)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/stop"
				;;
			container_restart)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/restart"
				;;
			container_remove)
				get_json_params id force depend
				require_param id "$id"
				validate_path_safe_id "$id"

				id_enc=$(urlencode "$id")
				# Build query parameters
				query=""
				is_true "$force" && query="${query}force=true&"
				is_true "$depend" && query="${query}depend=true&"
				# Remove trailing &
				query="${query%&}"
				# Add ? if we have parameters
				[ -n "$query" ] && query="?${query}"
				curl_request "DELETE" "${API_BASE}/containers/${id_enc}${query}"
				;;
			container_stats)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/stats?stream=false"
				;;
			container_create)
				get_json_params data
				require_param data "$data"
				curl_request "POST" "${API_BASE}/containers/create" "$data"
				;;
			container_rename)
				get_json_params id name

				require_param id "$id"
				require_param name "$name"
				validate_path_safe_id "$id"
				validate_container_name "$name"

				id_enc=$(urlencode "$id")
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/rename?name=${name_enc}"
				;;
			container_update)
				get_json_params id data
				require_param id "$id"
				require_param data "$data"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")

				json_load "$data"
				json_get_var restart_policy RestartPolicy
				json_get_var restart_retries RestartRetries
				validate_restart_policy "$restart_policy"

				query=""
				[ -n "$restart_policy" ] && query="${query}restartPolicy=${restart_policy}&"
				[ -n "$restart_retries" ] && query="${query}restartRetries=${restart_retries}&"

				query="${query%&}"

				[ -n "$query" ] && query="?${query}"

				case "$data" in
					*cpu*|*memory*|*blockIO*|*health*|*no_healthcheck*)
						# Send with body for resource/health updates
						curl_request "POST" "${API_BASE}/containers/${id_enc}/update${query}" "$data"
						;;
					*)
						# Query params only (restart policy) - but Podman still requires empty body
						curl_request "POST" "${API_BASE}/containers/${id_enc}/update${query}" "{}"
						;;
				esac
				;;
			container_healthcheck_run)
				get_json_params id
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/healthcheck"
				;;
			container_top)
				get_json_params id ps_args
				require_param id "$id"
				validate_path_safe_id "$id"
				id_enc=$(urlencode "$id")
				path="${API_BASE}/containers/${id_enc}/top"
				if [ -n "$ps_args" ]; then
					ps_args_enc=$(urlencode "$ps_args")
					path="${path}?ps_args=${ps_args_enc}"
				fi
				curl_request "GET" "$path"
				;;
			images_list)
				read -r input
				curl_request "GET" "${API_BASE}/images/json"
				;;
			image_inspect)
				get_json_params id
				require_param id "$id"
				validate_image_ref "$id"
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/images/${id_enc}/json"
				;;
			image_remove)
				get_json_params id force
				require_param id "$id"
				validate_image_ref "$id"
				id_enc=$(urlencode "$id")
				path=$(add_force "${API_BASE}/images/${id_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			image_manifest_inspect)
				get_json_params image
				require_param image "$image"
				validate_image_ref "$image"
				image_enc=$(urlencode "$image")
				curl_request "GET" "${API_BASE}/manifests/${image_enc}/json"
				;;
			networks_list)
				read -r input
				curl_request "GET" "${API_BASE}/networks/json"
				;;
			network_inspect)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/networks/${name_enc}/json"
				;;
			network_remove)
				get_json_params name force
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/networks/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			network_create)
				get_json_params data
				require_param data "$data"
				curl_request "POST" "${API_BASE}/networks/create" "$data"
				;;
			network_connect)
				get_json_params name data
				require_param name "$name"
				require_param data "$data"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/networks/${name_enc}/connect" "$data"
				;;
			network_disconnect)
				get_json_params name data
				require_param name "$name"
				require_param data "$data"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/networks/${name_enc}/disconnect" "$data"
				;;
			volumes_list)
				read -r input
				curl_request "GET" "${API_BASE}/volumes/json"
				;;
			volume_inspect)
				get_json_params name
				require_param name "$name"
				validate_volume_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/volumes/${name_enc}/json"
				;;
			volume_remove)
				get_json_params name force
				require_param name "$name"
				validate_volume_name "$name"
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/volumes/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			volume_create)
				get_json_params data
				require_param data "$data"
				curl_request "POST" "${API_BASE}/volumes/create" "$data"
				;;
			pods_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/pods/json"
				;;
			pod_inspect)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/pods/${name_enc}/json"
				;;
			pod_start)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/start"
				;;
			pod_stop)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/stop"
				;;
			pod_restart)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/restart"
				;;
			pod_pause)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/pause"
				;;
			pod_unpause)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/unpause"
				;;
			pod_remove)
				get_json_params name force
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/pods/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			pod_create)
				get_json_params data
				require_param data "$data"
				curl_request "POST" "${API_BASE}/pods/create" "$data"
				;;
			pod_stats)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/pods/stats?stream=false&namesOrIDs=${name_enc}"
				;;
			secrets_list)
				read -r input
				curl_request "GET" "${API_BASE}/secrets/json"
				;;
			secret_inspect)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/secrets/${name_enc}/json"
				;;
			secret_create)
				get_json_params name data
				require_param name "$name"
				require_param data "$data"
				validate_resource_name "$name"

				data_b64=$(printf '%s' "$data" | base64)
				name_enc=$(urlencode "$name")
				payload="\"${data_b64}\""

				curl_request "POST" "${API_BASE}/secrets/create?name=${name_enc}" "$payload"
				;;
			secret_remove)
				get_json_params name
				require_param name "$name"
				validate_resource_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "DELETE" "${API_BASE}/secrets/${name_enc}"
				;;
			system_df)
				read -r input
				curl_request "GET" "${API_BASE}/system/df"
				;;
			system_prune)
				get_json_params all volumes

				query=""
				is_true "$all" && query="${query}all=true&"
				is_true "$volumes" && query="${query}volumes=true&"

				query="${query%&}"

				[ -n "$query" ] && query="?${query}"
				curl_request "POST" "${API_BASE}/system/prune${query}"
				;;
			version)
				read -r input
				curl_request "GET" "${API_BASE}/version"
				;;
			info)
				read -r input
				curl_request "GET" "${API_BASE}/info"
				;;
			init_script_generate)
				get_json_params name

				require_param name "$name"
				validate_container_name "$name"

				# Read start priority from UCI and validate it's numeric (1-100)
				start_priority=$(uci -q get podman.globals.init_start_priority 2>/dev/null)
				case "$start_priority" in
					[1-9]|[1-9][0-9]|100) ;;
					*) start_priority="100" ;;
				esac

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				sed -e "s|{name}|$name|g" \
					-e "s|{start_priority}|$start_priority|g" \
					-e "s|{script_name}|$script_name|g" \
					"/usr/share/podman/procd-startup-template.sh" > "$script_path"

				chmod 755 "$script_path"

				if [ ! -x "$script_path" ]; then
					json_error "Failed to create init script"
					exit 1
				fi

				json_add_boolean success "1"
				json_add_string path "$script_path"
				json_dump

				;;
			init_script_show)
				get_json_params name

				require_param name "$name"
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					json_error "Init script not found"
					exit 1
				fi

				content=$(cat "$script_path")

				json_add_string content "$content"
				json_dump

				;;
			init_script_status)
				get_json_params name

				require_param name "$name"
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				exists="0"
				[ -f "$script_path" ] && exists="1"

				enabled="0"
				if [ -f "$script_path" ] && "${script_path}" enabled >/dev/null 2>&1; then
					enabled="1"
				fi

				json_add_boolean exists "$exists"
				json_add_boolean enabled "$enabled"
				json_dump
				;;
			init_script_set_enabled)
				get_json_params name enabled

				require_param name "$name"
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					json_error "Init script not found. Generate it first."
					exit 1
				fi

				if is_true "$enabled"; then
					"${script_path}" enable >/dev/null 2>&1
					exit_code=$?
					if [ $exit_code -ne 0 ]; then
						json_error "Failed to enable service" "" "$exit_code"
						exit 1
					fi
					enabled="1"
				else
					"${script_path}" disable >/dev/null 2>&1
					exit_code=$?
					if [ $exit_code -ne 0 ]; then
						json_error "Failed to disable service" "" "$exit_code"
						exit 1
					fi
					enabled="0"
				fi

				json_add_boolean success "1"
				json_add_boolean enabled "$enabled"
				json_dump
				;;
			init_script_remove)
				get_json_params name
				require_param name "$name"
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					json_add_boolean success "1"
					json_add_string message "Init script does not exist"
					json_dump
					exit 0
				fi

				"${script_path}" disable >/dev/null 2>&1
				rm -f "$script_path"

				if [ -f "$script_path" ]; then
					json_error "Failed to remove init script"
					exit 1
				fi

				json_add_boolean success "1"
				json_dump
				;;
			container_recreate)
				get_json_params command
				require_param command "$command"

				if [ -z "$command" ] || [ "$command" = "null" ]; then
					json_error "Invalid command: empty or null"
				fi

				first_arg=$(echo "$command" | jsonfilter -e '@[0]' 2>/dev/null)
				second_arg=$(echo "$command" | jsonfilter -e '@[1]' 2>/dev/null)

				if [ -z "$first_arg" ]; then
					json_error "Failed to parse command JSON"
				fi

				# Accept both "podman" and "/usr/bin/podman" (Podman stores full path in CreateCommand)
				case "$first_arg" in
					podman|/usr/bin/podman) ;;
					*) json_error "Invalid command: must start with podman" "got: ${first_arg}" ;;
				esac

				case "$second_arg" in
					run|create) ;;
					*) json_error "Invalid command: only run/create subcommands allowed" "got: ${second_arg}" ;;
				esac

				# Security: Limit argument count to prevent abuse (256 is generous for any real container)
				arg_count=$(echo "$command" | jsonfilter -e '@[*]' 2>/dev/null | wc -l)
				if [ "$arg_count" -gt 256 ]; then
					json_error "Invalid command: too many arguments"
				fi

				if echo "$command" | grep -qE '\&\&|\|\||[;<>]'; then
					json_error "Invalid command: contains forbidden shell characters"
				fi

				temp_script=$(mktemp)
				printf '#!/bin/sh\n/usr/bin/podman' > "$temp_script"

				echo "$command" | jsonfilter -e '@[*]' | tail -n +2 | while IFS= read -r arg; do
					escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
					printf " '%s'" "$escaped" >> "$temp_script"
				done

				printf '\n' >> "$temp_script"
				chmod 700 "$temp_script"

				result=$("$temp_script" 2>&1)
				exit_code=$?
				rm -f "$temp_script"

				if [ $exit_code -ne 0 ]; then
					json_error "Command failed" "$(printf '%s' "$result" | tr '\n' ' ')" "$exit_code"
					exit 1
				fi

				json_add_boolean success "1"
				json_dump
				;;
		esac
		;;
esac
