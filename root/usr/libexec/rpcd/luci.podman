#!/bin/sh
# RPC backend for LuCI Podman app

. /usr/share/libubox/jshn.sh

# Read socket path from UCI config, fallback to default
SOCKET=$(uci -q get podman.globals.socket_path 2>/dev/null)
SOCKET="${SOCKET:-/run/podman/podman.sock}"
API_BASE="/v5.0.0/libpod"

# URL encode a string (preserves : / @ for image references)
urlencode() {
	local string="$1" encoded="" char rest
	rest="$string"
	while [ -n "$rest" ]; do
		char="${rest%"${rest#?}"}"
		rest="${rest#?}"
		case "$char" in
			[-_.~a-zA-Z0-9:/@]) encoded="${encoded}${char}" ;;
			# *) printf -v char '%%%02x' "'$char"
			*) char=$(printf '%%%02x' "'$char")
			   encoded="${encoded}${char}" ;;
		esac
	done
	echo "$encoded"
}

# Validate container name (alphanumeric, dash, underscore only)
validate_container_name() {
	local name="$1"
	case "$name" in
		*[!a-zA-Z0-9_-]*)
			echo '{"error":"Invalid container name format"}'
			exit 1
			;;
	esac
}

# Validate volume name (alphanumeric, dash, underscore, dot only)
validate_volume_name() {
	local name="$1"
	case "$name" in
		*[!a-zA-Z0-9_.-]*)
			echo '{"error":"Invalid volume name format"}'
			exit 1
			;;
	esac
}

# Validate query parameters (only allow safe URL characters)
# Allows: alphanumeric, =, &, -, _, ., comma
validate_query_params() {
	local params="$1"
	case "$params" in
		*[!a-zA-Z0-9=\&_.,-]*)
			echo '{"error":"Invalid query parameters"}'
			exit 1
			;;
	esac
}

# Check boolean parameter (JSON booleans become 1/0 via ubus)
is_true() {
	[ "$1" = "true" ] || [ "$1" = "1" ]
}

# Get JSON parameters from input
get_json_params() {
	read -r input
	json_load "$input"
	for var in "$@"; do
		json_get_var "$var" "$var"
	done
}

# Validate required parameter
require_param() {
	local var_name="$1"
	eval "local var_value=\"\$$var_name\""
	if [ -z "$var_value" ]; then
		echo "{\"error\":\"Missing required parameter: $var_name\"}"
		exit 1
	fi
}

# Make curl request with error handling
curl_request() {
	local method="$1"
	local path="$2"
	local data="$3"
	local timeout="${4:-30}"
	local result exit_code

	if [ -n "$data" ]; then
		result=$(curl -s -m "$timeout" --unix-socket "$SOCKET" -X "$method" \
			-H "Content-Type: application/json" \
			-d "$data" \
			"http://localhost$path" 2>&1)
		exit_code=$?
	else
		result=$(curl -s -m "$timeout" --unix-socket "$SOCKET" -X "$method" \
			"http://localhost$path" 2>&1)
		exit_code=$?
	fi

	if [ $exit_code -ne 0 ]; then
		echo "{\"error\":\"Request failed\",\"details\":\"curl exit code $exit_code\"}"
		return $exit_code
	fi

	# Check if result is an array and wrap it in an object for ubus compatibility
	case "$result" in
		\[*)
			echo "{\"data\":$result}"
			;;
		*)
			echo "$result"
			;;
	esac
	return 0
}

# Add force parameter to path
add_force() {
	is_true "$2" && echo "${1}?force=true" || echo "$1"
}

case "$1" in
	list)
		cat <<EOF
{
	"containers_list": { "query": "" },
	"container_inspect": { "id": "" },
	"container_start": { "id": "" },
	"container_stop": { "id": "" },
	"container_restart": { "id": "" },
	"container_remove": { "id": "", "force": false, "depend": false },
	"container_stats": { "id": "" },
	"container_create": { "data": {} },
	"container_rename": { "id": "", "name": "" },
	"container_update": { "id": "", "data": {} },
	"container_healthcheck_run": { "id": "" },
	"container_top": { "id": "", "ps_args": "" },
	"images_list": {},
	"image_inspect": { "id": "" },
	"image_remove": { "id": "", "force": false },
	"image_manifest_inspect": { "image": "" },
	"networks_list": {},
	"network_inspect": { "name": "" },
	"network_remove": { "name": "", "force": false },
	"network_create": { "data": {} },
	"network_connect": { "name": "", "data": {} },
	"network_disconnect": { "name": "", "data": {} },
	"volumes_list": {},
	"volume_inspect": { "name": "" },
	"volume_remove": { "name": "", "force": false },
	"volume_create": { "data": {} },
	"volume_import": { "name": "", "data": "" },
	"pods_list": {},
	"pod_inspect": { "name": "" },
	"pod_start": { "name": "" },
	"pod_stop": { "name": "" },
	"pod_restart": { "name": "" },
	"pod_pause": { "name": "" },
	"pod_unpause": { "name": "" },
	"pod_remove": { "name": "", "force": false },
	"pod_create": { "data": {} },
	"pod_stats": { "name": "" },
	"secrets_list": {},
	"secret_inspect": { "name": "" },
	"secret_create": { "name": "", "data": "" },
	"secret_remove": { "name": "" },
	"system_df": {},
	"system_prune": { "all": false, "volumes": false },
	"version": {},
	"info": {},
	"init_script_generate": { "name": "" },
	"init_script_show": { "name": "" },
	"init_script_status": { "name": "" },
	"init_script_set_enabled": { "name": "", "enabled": false },
	"init_script_remove": { "name": "" },
	"container_recreate": { "command": [] }
}
EOF
		;;
	call)
		# Check socket availability
		if [ ! -S "$SOCKET" ]; then
			echo '{"error":"Podman socket not found or not accessible"}'
			exit 1
		fi

		case "$2" in
			containers_list)
				get_json_params query
				path="${API_BASE}/containers/json"
				if [ -n "$query" ]; then
					validate_query_params "$query"
					path="${path}?${query}"
				fi
				curl_request "GET" "$path"
				;;
			container_inspect)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/json"
				;;
			container_start)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/start"
				;;
			container_stop)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/stop"
				;;
			container_restart)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/restart"
				;;
			container_remove)
				get_json_params id force depend
				require_param id
				id_enc=$(urlencode "$id")
				# Build query parameters
				query=""
				is_true "$force" && query="${query}force=true&"
				is_true "$depend" && query="${query}depend=true&"
				# Remove trailing &
				query="${query%&}"
				# Add ? if we have parameters
				[ -n "$query" ] && query="?${query}"
				curl_request "DELETE" "${API_BASE}/containers/${id_enc}${query}"
				;;
			container_stats)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/stats?stream=false"
				;;
			container_create)
				get_json_params data
				curl_request "POST" "${API_BASE}/containers/create" "$data"
				;;
			container_rename)
				get_json_params id name
				require_param id
				require_param name
				id_enc=$(urlencode "$id")
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/containers/${id_enc}/rename?name=${name_enc}"
				;;
			container_update)
				get_json_params id data
				require_param id
				require_param data
				id_enc=$(urlencode "$id")

				# Parse the data JSON to extract restart policy (query params) and other resources (body)
				json_load "$data"
				json_get_var restart_policy RestartPolicy
				json_get_var restart_retries RestartRetries

				# Build query parameters for restart policy
				query=""
				[ -n "$restart_policy" ] && query="${query}restartPolicy=${restart_policy}&"
				[ -n "$restart_retries" ] && query="${query}restartRetries=${restart_retries}&"
				# Remove trailing &
				query="${query%&}"
				# Add ? if we have parameters
				[ -n "$query" ] && query="?${query}"

				# Check if we have resource/health updates (cpu, memory, blockIO, health) to send as body
				# If the JSON contains fields other than RestartPolicy/RestartRetries, send as body
				# This is a simple check - if data contains 'cpu', 'memory', 'blockIO', or 'health', use body
				case "$data" in
					*cpu*|*memory*|*blockIO*|*health*|*no_healthcheck*)
						# Send with body for resource/health updates
						curl_request "POST" "${API_BASE}/containers/${id_enc}/update${query}" "$data"
						;;
					*)
						# Query params only (restart policy) - but Podman still requires empty body
						curl_request "POST" "${API_BASE}/containers/${id_enc}/update${query}" "{}"
						;;
				esac
				;;
			container_healthcheck_run)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/containers/${id_enc}/healthcheck"
				;;
			container_top)
				get_json_params id ps_args
				require_param id
				id_enc=$(urlencode "$id")
				path="${API_BASE}/containers/${id_enc}/top"
				if [ -n "$ps_args" ]; then
					ps_args_enc=$(urlencode "$ps_args")
					path="${path}?ps_args=${ps_args_enc}"
				fi
				curl_request "GET" "$path"
				;;
			images_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/images/json"
				;;
			image_inspect)
				get_json_params id
				require_param id
				id_enc=$(urlencode "$id")
				curl_request "GET" "${API_BASE}/images/${id_enc}/json"
				;;
			image_remove)
				get_json_params id force
				require_param id
				id_enc=$(urlencode "$id")
				path=$(add_force "${API_BASE}/images/${id_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			image_manifest_inspect)
				get_json_params image
				require_param image
				image_enc=$(urlencode "$image")
				curl_request "GET" "${API_BASE}/manifests/${image_enc}/json"
				;;
			networks_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/networks/json"
				;;
			network_inspect)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/networks/${name_enc}/json"
				;;
			network_remove)
				get_json_params name force
				require_param name
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/networks/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			network_create)
				get_json_params data
				curl_request "POST" "${API_BASE}/networks/create" "$data"
				;;
			network_connect)
				get_json_params name data
				require_param name
				require_param data
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/networks/${name_enc}/connect" "$data"
				;;
			network_disconnect)
				get_json_params name data
				require_param name
				require_param data
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/networks/${name_enc}/disconnect" "$data"
				;;
			volumes_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/volumes/json"
				;;
			volume_inspect)
				get_json_params name
				require_param name
				validate_volume_name "$name"
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/volumes/${name_enc}/json"
				;;
			volume_remove)
				get_json_params name force
				require_param name
				validate_volume_name "$name"
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/volumes/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			volume_create)
				get_json_params data
				curl_request "POST" "${API_BASE}/volumes/create" "$data"
				;;
			volume_import)
				get_json_params name data compressed
				require_param name
				require_param data
				validate_volume_name "$name"

				# Base64 decode the uploaded tar data to temp file
				temp_file=$(mktemp /tmp/podman_vol_import_XXXXXX)
				# Conditionally decompress based on compressed parameter
				if [ "$compressed" = "true" ]; then
					echo "$data" | openssl base64 -d | gunzip -c > "$temp_file"
				else
					echo "$data" | openssl base64 -d > "$temp_file"
				fi
				decode_exit=$?

				if [ $decode_exit -ne 0 ]; then
					rm -f "$temp_file"
					echo "{\"error\":\"Failed to decode import data\"}"
					exit 1
				fi

				podman volume exists "$name"
				volume_exists=$?

				if [ $volume_exists -ne 0 ]; then
					# Create the volume first (import requires volume to exist)
					podman volume create "$name" > /dev/null 2>&1
					create_exit=$?

					if [ $create_exit -ne 0 ]; then
						rm -f "$temp_file"
						echo "{\"error\":\"Failed to create volume\",\"details\":\"podman exit code $create_exit\"}"
						exit 1
					fi
				fi

				# Use podman CLI since REST API doesn't support import yet
				podman volume import "$name" "$temp_file" > /dev/null 2>&1
				exit_code=$?
				rm -f "$temp_file"

				if [ $exit_code -ne 0 ]; then
					# Cleanup: remove the volume we just created if import fails
					podman volume rm "$name" 2>/dev/null
					echo "{\"error\":\"Import failed\",\"details\":\"podman exit code $exit_code\"}"
					exit 1
				fi

				# Import success
				echo "{\"success\":true}"
				;;
			pods_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/pods/json"
				;;
			pod_inspect)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/pods/${name_enc}/json"
				;;
			pod_start)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/start"
				;;
			pod_stop)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/stop"
				;;
			pod_restart)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/restart"
				;;
			pod_pause)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/pause"
				;;
			pod_unpause)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "POST" "${API_BASE}/pods/${name_enc}/unpause"
				;;
			pod_remove)
				get_json_params name force
				require_param name
				name_enc=$(urlencode "$name")
				path=$(add_force "${API_BASE}/pods/${name_enc}" "$force")
				curl_request "DELETE" "$path"
				;;
			pod_create)
				get_json_params data
				curl_request "POST" "${API_BASE}/pods/create" "$data"
				;;
			pod_stats)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/pods/stats?stream=false&namesOrIDs=${name_enc}"
				;;
			secrets_list)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/secrets/json"
				;;
			secret_inspect)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "GET" "${API_BASE}/secrets/${name_enc}/json"
				;;
			secret_create)
				get_json_params name data
				require_param name
				require_param data
				# Base64 encode the secret data
				# data_b64=$(echo -n "$data" | base64)
				data_b64=$(printf '%s' "$data" | base64)
				# URL encode the name for query parameter
				name_enc=$(urlencode "$name")
				# Build JSON payload - just the base64 data as a JSON string
				payload="\"${data_b64}\""
				curl_request "POST" "${API_BASE}/secrets/create?name=${name_enc}" "$payload"
				;;
			secret_remove)
				get_json_params name
				require_param name
				name_enc=$(urlencode "$name")
				curl_request "DELETE" "${API_BASE}/secrets/${name_enc}"
				;;
			system_df)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/system/df"
				;;
			system_prune)
				get_json_params all volumes
				# Build query parameters (check for both "true" and "1" since JSON booleans become 1/0)
				query=""
				is_true "$all" && query="${query}all=true&"
				is_true "$volumes" && query="${query}volumes=true&"
				# Remove trailing &
				query="${query%&}"
				# Add ? if we have parameters
				[ -n "$query" ] && query="?${query}"
				curl_request "POST" "${API_BASE}/system/prune${query}"
				;;
			version)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/version"
				;;
			info)
				read -r input  # consume ubus JSON input
				curl_request "GET" "${API_BASE}/info"
				;;
			init_script_generate)
				get_json_params name
				require_param name
				validate_container_name "$name"

				# Read start priority from UCI and validate it's numeric (1-100)
				start_priority=$(uci -q get podman.globals.init_start_priority 2>/dev/null)
				case "$start_priority" in
					[1-9]|[1-9][0-9]|100) ;;
					*) start_priority="100" ;;
				esac

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				sed -e "s|{name}|$name|g" \
					-e "s|{start_priority}|$start_priority|g" \
					-e "s|{script_name}|$script_name|g" \
					"/usr/share/podman/procd-startup-template.sh" > "$script_path"

				chmod +x "$script_path"

				if [ ! -x "$script_path" ]; then
					echo '{"error":"Failed to create init script"}'
					exit 1
				fi

				echo "{\"success\":true,\"path\":\"${script_path}\"}"
				;;
			init_script_show)
				get_json_params name
				require_param name
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					echo '{"error":"Init script not found"}'
					exit 1
				fi

				# Read script content and escape for JSON
				content=$(cat "$script_path" | sed 's/\\/\\\\/g; s/"/\\"/g' | awk '{printf "%s\\n", $0}')
				echo "{\"content\":\"${content}\"}"
				;;
			init_script_status)
				get_json_params name
				require_param name
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				# Check if script exists
				exists="false"
				[ -f "$script_path" ] && exists="true"

				# Check if enabled using the script's enabled command
				enabled="false"
				if [ -f "$script_path" ] && "${script_path}" enabled >/dev/null 2>&1; then
					enabled="true"
				fi

				echo "{\"exists\":${exists},\"enabled\":${enabled}}"
				;;
			init_script_set_enabled)
				get_json_params name enabled
				require_param name
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					echo '{"error":"Init script not found. Generate it first."}'
					exit 1
				fi

				# Check for both "true" and "1" since JSON booleans become 1/0
				if is_true "$enabled"; then
					# Enable service
					"${script_path}" enable >/dev/null 2>&1
					exit_code=$?
					if [ $exit_code -ne 0 ]; then
						echo "{\"error\":\"Failed to enable service\",\"exit_code\":${exit_code}}"
						exit 1
					fi
					echo '{"success":true,"enabled":true}'
				else
					# Disable service
					"${script_path}" disable >/dev/null 2>&1
					exit_code=$?
					if [ $exit_code -ne 0 ]; then
						echo "{\"error\":\"Failed to disable service\",\"exit_code\":${exit_code}}"
						exit 1
					fi
					echo '{"success":true,"enabled":false}'
				fi
				;;
			init_script_remove)
				get_json_params name
				require_param name
				validate_container_name "$name"

				script_name="container-${name}"
				script_path="/etc/init.d/${script_name}"

				if [ ! -f "$script_path" ]; then
					# Not an error - already removed
					echo '{"success":true,"message":"Init script does not exist"}'
					exit 0
				fi

				# Disable first (removes symlinks)
				"${script_path}" disable >/dev/null 2>&1

				# Remove script file
				rm -f "$script_path"

				if [ -f "$script_path" ]; then
					echo '{"error":"Failed to remove init script"}'
					exit 1
				fi

				echo '{"success":true}'
				;;
			container_recreate)
				get_json_params command
				require_param command

				# Validate command is not empty and is valid JSON array
				if [ -z "$command" ] || [ "$command" = "null" ]; then
					echo '{"error":"Invalid command: empty or null"}'
					exit 1
				fi

				# Security: Validate command structure
				first_arg=$(echo "$command" | jsonfilter -e '@[0]' 2>/dev/null)
				second_arg=$(echo "$command" | jsonfilter -e '@[1]' 2>/dev/null)

				# Check if jsonfilter parsing succeeded
				if [ -z "$first_arg" ]; then
					echo '{"error":"Failed to parse command JSON"}'
					exit 1
				fi

				# Accept both "podman" and "/usr/bin/podman" (Podman stores full path in CreateCommand)
				case "$first_arg" in
					podman|/usr/bin/podman)
						;;
					*)
						echo "{\"error\":\"Invalid command: must start with podman\",\"details\":\"got: ${first_arg}\"}"
						exit 1
						;;
				esac

				# Only allow run/create subcommands for container recreation
				case "$second_arg" in
					run|create)
						;;
					*)
						echo "{\"error\":\"Invalid command: only run/create subcommands allowed\",\"details\":\"got: ${second_arg}\"}"
						exit 1
						;;
				esac

				# Security: Limit argument count to prevent abuse (256 is generous for any real container)
				arg_count=$(echo "$command" | jsonfilter -e '@[*]' 2>/dev/null | wc -l)
				if [ "$arg_count" -gt 256 ]; then
					echo '{"error":"Invalid command: too many arguments"}'
					exit 1
				fi

				# Security: Check for shell metacharacters in command structure
				# Note: backticks, $(), ${} can appear legitimately in labels (e.g., Traefik rules)
				# They are safely neutralized by single-quote escaping of each argument below
				if echo "$command" | grep -qE '\&\&|\|\||[;<>]'; then
					echo '{"error":"Invalid command: contains forbidden shell characters"}'
					exit 1
				fi

				# Create temp script with properly quoted command
				temp_script=$(mktemp /tmp/podman_cmd_XXXXXX)
				printf '#!/bin/sh\n/usr/bin/podman' > "$temp_script"

				# Skip first element ("podman"), quote all remaining arguments
				echo "$command" | jsonfilter -e '@[*]' | tail -n +2 | while IFS= read -r arg; do
					# Escape single quotes for shell safety
					escaped=$(printf '%s' "$arg" | sed "s/'/'\\\\''/g")
					printf " '%s'" "$escaped" >> "$temp_script"
				done

				printf '\n' >> "$temp_script"
				# chmod +x "$temp_script"
				chmod 700 "$temp_script"

				# Execute and capture output
				result=$("$temp_script" 2>&1)
				exit_code=$?
				rm -f "$temp_script"

				if [ $exit_code -ne 0 ]; then
					# Escape result for JSON
					result_escaped=$(printf '%s' "$result" | sed 's/\\/\\\\/g; s/"/\\"/g' | tr '\n' ' ')
					echo "{\"error\":\"Command failed\",\"details\":\"${result_escaped}\",\"exit_code\":${exit_code}}"
					exit 1
				fi

				echo '{"success":true}'
				;;
		esac
		;;
esac
